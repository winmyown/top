<style>
body {

            background-image: url("data:image/jpeg;base64,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");
        }
</style>

## IO中接口、抽象类



# hell
asfasdfsdfdsfsdfsd
> test
> sdfa
> 
# 111
## 222
### InputStream
<details>
<summary>InputStream方法注释</summary>

```java
public void main(String[] args){
    System.out.println("test");
}
```

```java
package java.io;

/**
 * 这个抽象类是表示字节输入流的所有类的超类。
 需要定义 的 InputStream 子类的应用程序必须始终提供一个返回输入的下一个字节的方法。
 自从：
 JDK1.0版本
 另请参见：
 BufferedInputStream, 
 ByteArrayInputStream, 
 DataInputStream, 
 FilterInputStream, 
 read(), 
 OutputStream, 
 PushbackInputStream
 作者：
 亚瑟·范·霍夫
 */
public abstract class InputStream implements Closeable {

    // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to
    // use when skipping.
    private static final int MAX_SKIP_BUFFER_SIZE = 2048;

    /**
     * 从输入流中读取数据的下一个字节。值 byte 在 的范围内0作为 返回int。255
     * 如果由于已到达流的末尾而没有可用的字节，则返回该值-1。在输入数据可用、检测到流的末尾或引发异常之前，此方法将阻塞。
     子类必须提供此方法的实现。
     返回：
     数据的下一个字节，或者 -1 如果到达流的末尾。
     抛出：
     IOException – 如果发生 I/ O 错误。
     */
    public abstract int read() throws IOException;

    /**
     * 从输入流中读取一定数量的字节，并将它们存储到缓冲区数组 b中。实际读取的字节数以整数形式返回。
     * 在输入数据可用、检测到文件结尾或引发异常之前，此方法将阻塞。
     如果 的 b 长度为零，则不会读取并 0 返回任何字节;
     否则，将尝试读取至少一个字节。如果由于流位于文件的末尾而没有可用的字节，则返回该值 -1 ;
     否则，至少有一个字节被读取并存储到 b。
     第一个字节读取被存储到 元素b[0]中，下一个字节被存储到 b[1]中，依此类推。
     读取的字节数最多等于 的长度b。设 k 为实际读取的字节数;这些字节将通过 b[K-1] 存储在元素b[0]中，而元素 b[K] 通过b[b. length-1]不受影响。
     read(b) class InputStream 的方法具有与以下相同的效果：
     read(b, 0, b. length) 
     参数：
     b – 读取数据的缓冲区。
     返回：
     读入缓冲区的总字节数，或者 -1 如果由于已到达流的末尾而没有更多数据。
     抛出：
     IOException – 如果由于文件末尾以外的任何原因无法读取第一个字节，如果输入流已关闭，或者如果发生其他 I/ O 错误。
     NullPointerException – 如果 b 是 null.
     另请参见：
     read(byte[], int, int)
     * @exception  NullPointerException  if <code>b</code> is <code>null</code>.
     * @see        java.io.InputStream#read(byte[], int, int)
     */
    public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }

    /**
     * 从输入流中读取最多 len 字节的数据到字节数组中。尝试读取尽可能多的 len 字节，但可以读取较小的数字。实际读取的字节数以整数形式返回。
     在输入数据可用、检测到文件结尾或引发异常之前，此方法将阻止。
     如果 len 为零，则不读取并 0 返回任何字节;否则，尝试至少读取一个字节。如果由于流位于文件末尾而没有可用的字节，则返回该值 -1 ;否则，至少有一个字节被读取并存储到 b。
     第一个字节读取被存储到 元素b[off]中，下一个字节被存储到 b[off+1]中，依此类推。读取的字节数最多等于 len。设 k 为实际读取的字节数;这些字节将通过 b[off+K-1] 存储在元素b[off]中，而元素 b[off+K] 通过b[off+len-1]不受影响。
     在每种情况下，元素 b[0] 通过 b[off] 和 b[off+len] 元素通过 b[b. length-1] 都不受影响。
     read(b, len) off, class InputStream 的方法只是重复调用该方法read()。如果第一次此类调用导致 IOException，则从对read(b, off, len)该方法的调用中返回该异常。如果任何后续调用read()导致 IOException，则将捕获异常并将其视为文件末尾;到该点为止读取的字节将被存储到b该点，并返回异常发生之前读取的字节数。在读取了请求的输入数据len量、检测到文件末尾或引发异常之前，此方法的默认实现将阻塞。鼓励子类更有效地实现此方法。
     参数：
     b – 读取数据的缓冲区。 off – 写入数据的数组 b 中的起始偏移量。 len – 要读取的最大字节数。
     返回：
     读入缓冲区的总字节数，或者 -1 如果由于已到达流的末尾而没有更多数据。
     抛出：
     IOException – 如果由于文件结束以外的任何原因无法读取第一个字节，或者如果输入流已关闭，或者如果发生其他 I/ O 错误。
     NullPointerException – 如果 b 是 null.
     IndexOutOfBoundsException – 如果 off 为负数、 len 为负数或 len 大于 b. length - off
     另请参见：
     read()
     */
    public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }

        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }

    /**
     * 跳过并丢弃 n 此输入流中的字节数据。由于各种原因，该 skip 方法最终可能会跳过一些较少数量的字节，可能是 0。
     * 这可能是由多种条件中的任何一种造成的;在跳过字节之前 n 到达文件末尾只是一种可能性。返回跳过的实际字节数。
     * 如果 n 为负数， skip 则 class InputStream 的方法始终返回 0，并且不会跳过任何字节。子类可能会以不同的方式处理负值。
     skip此类的方法创建一个字节数组，然后重复读取该数组，直到n读取字节或到达流的末尾。鼓励子类更有效地实现此方法。
     例如，实施可能取决于寻求的能力。
     参数：
     n – 要跳过的字节数。
     返回：
     跳过的实际字节数。
     抛出：
     IOException – 如果流不支持查找，或者发生其他 I/ O 错误
     */
    public long skip(long n) throws IOException {

        long remaining = n;
        int nr;

        if (n <= 0) {
            return 0;
        }

        int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
        byte[] skipBuffer = new byte[size];
        while (remaining > 0) {
            nr = read(skipBuffer, 0, (int)Math.min(size, remaining));
            if (nr < 0) {
                break;
            }
            remaining -= nr;
        }

        return n - remaining;
    }

    /**
     * 返回可以从此输入流中读取（或跳过）的字节数的估计值，而不会被下次调用此输入流的方法阻塞。下一次调用可能是同一线程或另一个线程。对这么多字节的单次读取或跳过不会阻塞，但可能会读取或跳过较少的字节。
     请注意，虽然 的某些 InputStream 实现将返回流中的总字节数，但许多实现不会。使用此方法的返回值来分配旨在保存此流中的所有数据的缓冲区，这是绝对不正确的。
     如果此输入流已通过调用该close()方法关闭，则此方法的子类实现可以选择抛出。IOException
     available class InputStream 的方法总是返回 0。
     此方法应由子类重写。
     返回：
     可以从此输入流中读取（或跳过）而不会阻塞或 0 到达输入流末尾时的字节数的估计值。
     抛出：
     IOException – 如果发生 I/ O 错误。
     */
    public int available() throws IOException {
        return 0;
    }

    /**
     * 关闭此输入流并释放与该流关联的任何系统资源。
     该closeInputStream方法不做任何事情。
     抛出：
     IOException – 如果发生 I/ O 错误。
     */
    public void close() throws IOException {}

    /**
     * 标记此输入流中的当前位置。对该 reset 方法的后续调用将此流重新定位到最后标记的位置，
     * 以便后续读取重新读取相同的字节。
     参数 readlimit 告诉此输入流允许在标记位置失效之前读取许多字节。
     的一般mark约定是，如果方法markSupported返回true，
     则流会以某种方式记住在调用 to mark 之后读取的所有字节，
     并随时准备在调用方法reset时再次提供这些相同的字节。
     但是，如果在调用流之前reset从流中读取的字节数超过readlimit字节，则根本不需要流记住任何数据。
     标记已关闭的流不应对流产生任何影响。
     该markInputStream方法不做任何事情。
     参数：
     readlimit – 在标记位置无效之前可以读取的最大字节限制。
     另请参见：
     reset()
     */
    public synchronized void mark(int readlimit) {}

    /**
     * 将此流重新定位到上次在此输入流上调用该方法时 mark 的位置。
     公司 reset 的总合同为：
     如果该方法 markSupported 返回 true，则：
     如果自创建流以来未调用该方法mark，或者自上次调用以来mark从流中读取的字节数大于最后一次调用时的参数mark，则可能会引发 。IOException
     如果未抛出此类 a IOException ，则流将重置为一种状态，
     即自最近一次调用 mark 以来（或自文件开始以来，如果 mark 尚未调用）
     读取的所有字节都将重新提供给该 read 方法的后续调用者，然后是截至调用 时 reset本应是下一个输入数据的任何字节。
     如果该方法 markSupported 返回 false，则：
     调用 可能会 reset 抛出 IOException.
     如果未抛出 an IOException ，则流将重置为固定状态，该状态取决于输入流的特定类型及其创建方式。
     将提供给该方法的 read 后续调用方的字节取决于输入流的特定类型。
     class InputStream 的方法reset除了抛出一个 IOException.
     抛出：
     IOException – 如果此流未被标记或标记已失效。
     另请参见：
     mark(int), IOException
     */
    public synchronized void reset() throws IOException {
        throw new IOException("mark/reset not supported");
    }

    /**
     * 测试此输入流是否支持 mark and reset 方法。
     * whether or or are mark supported 是reset特定输入流实例的不变属性。
     * markSupported返回false的方法InputStream。
     返回：
     true 如果此流实例支持 mark 和 reset 方法; false 否则。
     另请参见：
     mark(int), reset()
     */
    public boolean markSupported() {
        return false;
    }

}

```
</details>