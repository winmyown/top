package org.top.java.concurrent.source.locks;

/**
 * @Author zack
 * @Description
 * @Date 2024/10/14 下午1:42
 */

import java.util.concurrent.locks.Lock;

/**
 * <p>ReadWriteLock 维护一对关联的锁，一个用于只读操作，一个用于写操作。只要没有写线程，多个读线程可以同时持有读锁。写锁是排他性的。</p>
 * <p>所有 ReadWriteLock 实现都必须保证 <code>writeLock</code> 操作（如 Lock 接口中所规定）的内存同步效果同样适用于关联的 <code>readLock</code>。也就是说，成功获取读锁的线程将能够看到在之前释放写锁时所做的所有更新。</p>
 * <p>读写锁允许比互斥锁在访问共享数据时提供更高的并发级别。它利用了这样一个事实：虽然一次只能有一个线程（写线程）修改共享数据，但在许多情况下，任何数量的线程可以同时读取数据（即读线程）。理论上，通过使用读写锁所允许的并发增加将带来比使用互斥锁更好的性能提升。而在实践中，这种并发性的提升只有在多处理器上，并且在共享数据的访问模式适合时才能完全实现。</p>
 * <p>读写锁是否会比使用互斥锁提高性能取决于数据的读取频率与修改频率的比较，读写操作的持续时间，以及对数据的争用情况——也就是说，有多少线程同时尝试读取或写入数据。例如，一个最初填充了数据的集合，之后很少被修改，但经常被查询（例如某种目录）是使用读写锁的理想候选者。然而，如果更新变得频繁，数据的大部分时间都将处于排他锁定状态，并发性几乎没有增加，甚至根本没有增加。此外，如果读操作过于短暂，读写锁实现的开销（本质上比互斥锁复杂得多）可能会主导执行成本，尤其是许多读写锁实现仍然通过一小段代码将所有线程串行化。最终，只有通过分析和测量才能确定使用读写锁是否适合你的应用程序。</p>
 * <p>尽管读写锁的基本操作相对简单，但实现时有许多策略决策，这些决策可能会影响读写锁在特定应用程序中的有效性。以下是这些策略的示例：</p>
 * <ul>
 * <li>在读写线程同时等待时，决定是授予读锁还是写锁，当写线程释放写锁时。写线程优先的策略很常见，因为写操作通常短暂且不频繁。读线程优先的策略较少见，因为如果读线程频繁且长时间存在，这可能会导致写操作的长时间延迟。公平或“按顺序”实现也是可能的。</li>
 * <li>在一个读线程活动且有一个写线程正在等待时，决定是否授予请求读锁的读线程。优先考虑读线程可能会无限期地延迟写线程，而优先考虑写线程则可能减少并发的潜力。</li>
 * <li>确定锁是否可重入：拥有写锁的线程是否可以重新获取写锁？它是否可以在持有写锁的同时获取读锁？读锁本身是否是可重入的？</li>
 * <li>写锁是否可以在不允许其他写线程介入的情况下降级为读锁？读锁是否可以优先于其他等待的读线程或写线程升级为写锁？</li>
 *
 * </ul>
 * <p>在评估给定实现是否适合你的应用程序时，应考虑所有这些因素。</p>
 * <p>自版本 1.5 起提供。</p>
 * <p>参考：</p>
 * <ul>
 * <li>ReentrantReadWriteLock</li>
 * <li>Lock</li>
 * <li>ReentrantLock</li>
 *
 * </ul>
 * <p>作者：Doug Lea</p>
 */
public interface ReadWriteLock {
    /**
     * 返回读锁
     *
     * @return the lock used for reading
     */
    Lock readLock();

    /**
     * 返回写锁
     *
     * @return the lock used for writing
     */
    Lock writeLock();
}
